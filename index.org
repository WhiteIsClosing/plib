#+STYLE: <link rel="stylesheet" type="text/css" href="./style/yinwang0.css" />
Very short Ruby tutorials for my YY.
* 安装和配置
** 安装
*** Windows
    前往 http://rubyinstaller.org/ 下载.
*** Mac OS && Linux
    已经自带, 可以使用 [[https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF][终端]] 打开. 
** 基本的开发环境
   一个基本的开发环境包括两个部分:
   1. 编写程序的部分(编辑器)
   2. 执行程序的部分(解释器)
*** 编辑器的选择
    可以使用任何的[[https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8][文本编辑器]], 可以考虑的如下:
    1. 自带的记事本
    2. Notepad++: http://notepad-plus-plus.org/
    3. atom: https://atom.io/
    4. vim: http://www.vim.org/download.php
    5. emacs: http://mirror.keystealth.org/gnu/emacs/windows/
*** 解释器的说明
    解释器可以使用两种模式: 1. 交互模式. 2. 批处理模式
    两者的不同如下:
**** 交互模式
     使用irb, 进入后会有如下的显示:
#+begin_src bash
irb(main):001:0> 
#+end_src
     在这一模式下, 每写一行(敲回车后), 解释器都会立即执行. 这样, 每一步的执行的结果都可以知道.
**** 批处理模式
     使用 ruby 命令, 在Windows下, 编写文件后保存成.rb文件, 点击就会是批处理模式. 批处理模式会一次性执行.rb文件中的所有内容, 或者遇到文件中出现错误, 或者执行完毕, 也有可能会永远运行下去(你可以选择强行停止).
* 基本语法
  编程语言作为一门语言, 和普通的中文\英文等具有很多的相似点. 学习一门语言的过程都是一样的(认字->认词->学习语法->读文章->写文章), Ruby的字符都是英文字符, 不需要额外学习. Ruby中需要专门学习的词语也很少, 在100以内, 很多词语也是语法的组成部分之一, 所以语法是Ruby语言的基础.
** 表达式
   表达式可以认为是编程语言中的一句话. 可以认为是来自于数学表达式, 比如: $1+2, 3*14+2$ 等等. 

   表达式是一个表示运算的过程, 而其结果则是运算的目的, 可以写一个解一个一元二次方程的表达式, 如下, 我们来解 $x^2 + 4x + 1 = 0$ 这一方程两个解的表达式就是:
   $$x_1 = \frac{-4 + \sqrt{4^2 - 4\times 1\times 1}}{2}$$
   $$x_2 = \frac{-4 - \sqrt{4^2 - 4\times 1\times 1}}{2}$$

   如果我们需要使用Ruby来写出上面的两个表达式, 则需要注意以下几点:
   1. 乘法在Ruby中的形式为 1*2
   2. 除法在Ruby中的形式为 32/8
   3. 开平方的形式则为 Math.sqrt(3.5)
   4. 平方的形式则为 3**2 (3的平方)


   如此, 上面的两个表达式在Ruby中会是如下:
#+begin_src ruby
x1 = (-4+Math.sqrt(4**2 - 4*1*1) )/2
x2 = (-4-Math.sqrt(4**2 - 4*1*1) )/2
#+end_src
   如果将这两句话复制, 放入irb中分别执行, 结果会分别是
#+begin_src sh
irb(main):003:0> x1 = (-4+Math.sqrt(4**2 - 4*1*1) )/2
=> -0.2679491924311228
irb(main):004:0> x2 = (-4-Math.sqrt(4**2 - 4*1*1) )/2
=> -3.732050807568877
#+end_src
   你会发现, 每执行一句表达式, 表达式的结果都会在irb的模式中显示出来.

** 可以通用的表达式 - 变量
   利用上面的表达式, 已经可以用于解一元二次方程, 但是不同的方程都需要输入整个表达式, 为了增加灵活性, 我们需要引入一个更加抽象[fn:1]的概念: 变量

*** 变量 vs 常量
    变量是一个可以变化的值, 对应的, 不变化的值会是常数, 在数学中最明显的一个常量就是圆周率: $\pi$ .
*** 变量表达式
    由于变量是一次抽象, 我们需要一个符号系统来表达这样的一次抽象, 形成一个更加通用的表达式. 事实上, 一元二次方程的通用表示就是存在变量的表达式:
    $$ax^2+bx+c=0 $$
    对应的, 其解的通用表达式就是:
    $$ x_{0,1}=\frac{-b \pm \sqrt{b^2 - 4\times a\times c}}{2\times a}$$

*** Ruby中通用解的表达式
    按照上面的通用表达式的表示, 我们就可以写出两个解在Ruby中的通用表示
#+begin_src ruby
x1 = (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
x2 = (-b-Math.sqrt(b**2 - 4*a*c) )/ (2*a)
#+end_src
    
    当然, 如果直接输入这一表达式, 会出现错误:
#+begin_src sh
irb(main):005:0> x1 = (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
NameError: undefined local variable or method `b' for main:Object
	from (irb):5
	from /usr/bin/irb:12:in `<main>'
#+end_src
    
    这一错误的原因在于, 上述表达式的=右侧, 是抽象的, 我们尚未制定 a, b, c三者的值, 而=右侧希望获得的是一个具体的值. 为此, 我们需要指定a, b, c的具体值. 在irb中的过程如下:
#+begin_src sh
irb(main):014:0> a = 1
=> 1
irb(main):015:0> b = 4
=> 4
irb(main):016:0> c = 1
=> 1
irb(main):017:0> x1 = (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
=> -0.2679491924311228
irb(main):018:0> 
#+end_src
    x2的表达式也类似, 但是由于在之前已经有了指定, 就不再需要重新指定 a, b, c三者的值了. 这样, 之后的计算就不再需要根据a, b, c的不同值重新输入整个表达式了, 只需要重新指定a, b, c然后使用相同的通用表达式就可以获得方程的解了.

    我们可以将变量理解为一个桶, 根据需要, 往桶里放东西. 那么上面的通用表达式可以认为是针对名字分别叫做a b c的三个桶中装的东西的生产线. 我们每次将不同的原料往桶里装, 然后送到生产线中, 经过一番加工后就会获得生产线的产品, 这里, 我们叫这条生产线为"获得一元二次方程的解", 生产线的原料则是"组成方程的三个数值", 此时作为工人的我们, 需要知道生产线的使用说明: "按照严格的顺序, 将三个数值放入对应的桶里, 启动生产, 就会获得结果". 考虑到, 这一生产线其实也是我们设计+建造的, 从这个角度来看, 我们又是设计和生成这一生产线的工程师+工人.
    
    其实, 我们连每次重新输入通用表达式都觉得太麻烦. 这其实就是进一步抽象的动机(懒惰). 我们可以将通用表达式也指定到一个变量上, 后续, 比如起个名字叫做 "生产线1", 以后就不用每次都把整个生成线都写出来了. 这一懒惰的行为, 我们暂时不表, 后面会再深入"懒惰"这个主题.

** 更加复杂的表达式 - 程序的流程
   如果我们在irb中输入下面的内容, 就会出现错误:
#+begin_src sh
irb(main):026:0> a = 4
=> 4
irb(main):027:0> b = 1
=> 1
irb(main):028:0> c = 3
=> 3
irb(main):029:0> (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
Math::DomainError: Numerical argument is out of domain - "sqrt"
	from (irb):29:in `sqrt'
	from (irb):29
	from /usr/bin/irb:12:in `<main>'
#+end_src
   因为, 方程存在无解的情况, 我们不能对负数进行开方(起码目前不能). 那么, 问题来了, 我们如何判断方程是否有解和无解呢?
*** 判断语句 - if
    if语句的作用就是用于对某一个逻辑是真还是假的判断. 对于计算机程序来言, 不会存在人类在逻辑判断时的模糊区域, 计算机程序的判断只有逻辑是真还是假两个结果. 牛津通识读本中有一本介绍 /简明逻辑学/ 可以用于学习,了解和熟悉计算机程序的逻辑系统.
    下面是if的最基本的语法结构, 只做一次判断, 如果条件判断中的内容是真的, 就会执行表达式的内容:
#+begin_src ruby
if 条件判断
    表达式
end
#+end_src
    自然的, 如果既需要处理表达式为真的情况, 也需要处理表达式为假的情况, 其实可以利用上面的格式, 使用前后两个if来处理, 但是Ruby在语法上提供了更加简明的方法:
#+begin_src ruby
if 条件判断
    表达式1
else
    表达式2
end
#+end_src
    这样的情况下, 如果条件判断为假, 则会执行后面的表达式2. 那么, 条件判断如果有多个相互独立的情况, 如何处理呢? 利用上面的条件判断, 可以利用多个if-else语句的嵌套来实现, 不过, Ruby还是提供了更加简明的方法:
#+begin_src ruby
if 条件判断1
    表达式1
elsif 条件判断2
    表达式2
elsif 条件判断3
    表达式3
else
    表达式4
end
#+end_src
    我们可以举例来使用这三种形式, 首先, 如果我们的程序要特别的针对男孩准备更多的运动器材, 那么程序的逻辑就会如下:
#+begin_src ruby
if 是男孩
   准备更多的运动器材
end
#+end_src
    OK, 完成了运动器材的准备, 但是, 假如还要为女孩准备更多的芭比娃娃呢?
#+begin_src ruby
if 是男孩
   准备更多的运动器材
else
   准备更多的芭比娃娃
end
#+end_src
    当然, 这个语句也可以根据你自己的风格来调整, 只要在逻辑上是等价的, 程序结果也会是一致的:
#+begin_src ruby
if 是女孩
   准备更多的芭比娃娃
else
   准备更多的运动器材   
end
#+end_src
    这句话和上面的那句是等价的, 结果也会是一致的(从目前的假设来看). 可是, 这一逻辑的前提是性别只有两种可能, 女孩或者男孩. 如果出现了第三种情况怎么办? 那么前面的两个语句对第三种情况的处理是不一致的, 也就是说逻辑不再是等价的了.
    这里, 涉及到了一个编程时很容易出现的问题, 那就是"假设的错误". 程序是一个由程序的编写者建立的一套体系, 类似数学体系一般, 在编写的过程中编写者会利用自己的逻辑和理论逐渐推演出整个程序, 但是, 却很容易出现一个错误: 这一体系的基础是否正确. 譬如数学体系中的公理, 如果发生了变化或者不再成立, 那么整个以此为基础的体系都需要做大量的修正. 程序也如此, 如果编写者的最开始的几个假设有漏洞, 即使这一程序本身是自恰的, 由于程序本身的基本假设有错误, 程序也会出现不正确的情况.
    这里的假设错误就是, 我们假设性别只有男性和女性, 但是实际情况却有可能不只是这两种, 譬如:双性人. 那么更加严密的逻辑会是:
#+begin_src ruby
if 是女孩
   准备更多的芭比娃娃
elsif 是男孩
   准备更多的运动器材
else
   都多多准备
end
#+end_src
    但是既然我们已经知道了第三种情况, 或许就会有第四种和第五种情况, 我们需要更加严密的处理这些情况:
#+begin_src ruby
if 是女孩
   准备更多的芭比娃娃
elsif 是男孩
   准备更多的运动器材
elsif 是双性人
   都多多准备
else
   需要咨询更多信息才能决定
end
#+end_src
    这样, 我们就能将更多的情况考虑到自己的假设范围内, 保证在这一范围内的逻辑等价.
*** 逻辑系统
    Ruby的逻辑操作+特殊的一些True/False的默认情况
*** while与break
    不断解多个方程
** 处理复杂的表达式 - 模块化 - 函数/子例程/代码快/方法
*** 实数解与复数解
** 解释与可读性 - 注释
** 程序正确的基石 - 类型系统
   就像我们对家人的称呼, 父母[fn:2]可以认为是常量, 因为我们的父母不会有变化, 出生时就决定了.
   与物理单位的类似性
** 常用类型 - string
** 外界的交互 - IO系统
** 常用类型 - 标准库
** 现实世界的投射 - 面向对象
** 与代码质量的长期斗争 - 版本控制/复查/测试
** 乐高积木 - 模块化
** 编写自己的网站 - Rails
*** HTTP协议的过程
** Meta Programming
* Footnotes

[fn:1] 编写程序就是一个抽象与具体互相转化的过程.

[fn:2] 我们只考虑在现有技术条件下, 生物学意义上的父母.



