#+STYLE: <link rel="stylesheet" type="text/css" href="./style/yinwang0.css" />

Very short Ruby tutorials for my YY.

* 安装和配置
** 安装
*** Windows
    前往 http://rubyinstaller.org/ 下载.
*** Mac OS && Linux
    已经自带, 可以使用 [[https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E7%BB%88%E7%AB%AF][终端]] 打开. 
** 基本的开发环境
   一个基本的开发环境包括两个部分:
   1. 编写程序的部分(编辑器)
   2. 执行程序的部分(解释器)
*** 编辑器的选择
    可以使用任何的[[https://zh.wikipedia.org/wiki/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8][文本编辑器]], 可以考虑的如下:
    1. 自带的记事本
    2. Notepad++: http://notepad-plus-plus.org/
    3. atom: https://atom.io/
    4. vim: http://www.vim.org/download.php
    5. emacs: http://mirror.keystealth.org/gnu/emacs/windows/
*** 解释器的说明
    解释器可以使用两种模式: 1. 交互模式. 2. 批处理模式
    两者的不同如下:
**** 交互模式
     使用irb, 进入后会有如下的显示:
#+begin_src bash
irb(main):001:0> 
#+end_src
     在这一模式下, 每写一行(敲回车后), 解释器都会立即执行. 这样, 每一步的执行的结果都可以知道.
**** 批处理模式
     使用 ruby 命令, 在Windows下, 编写文件后保存成.rb文件, 点击就会是批处理模式. 批处理模式会一次性执行.rb文件中的所有内容, 或者遇到文件中出现错误, 或者执行完毕, 也有可能会永远运行下去(你可以选择强行停止).
* 基本语法
  编程语言作为一门语言, 和普通的中文\英文等具有很多的相似点. 学习一门语言的过程都是一样的(认字->认词->学习语法->读文章->写文章), Ruby的字符都是英文字符, 不需要额外学习. Ruby中需要专门学习的词语也很少, 在100以内, 很多词语也是语法的组成部分之一, 所以语法是Ruby语言的基础.
** 表达式
   表达式可以认为是编程语言中的一句话. 可以认为是来自于数学表达式, 比如: $1+2, 3*14+2$ 等等. 

   表达式是一个表示运算的过程, 而其结果则是运算的目的, 可以写一个解一个一元二次方程的表达式, 如下, 我们来解 $x^2 + 4x + 1 = 0$ 这一方程两个解的表达式就是:
   $$x_1 = \frac{-4 + \sqrt{4^2 - 4\times 1\times 1}}{2}$$
   $$x_2 = \frac{-4 - \sqrt{4^2 - 4\times 1\times 1}}{2}$$

   如果我们需要使用Ruby来写出上面的两个表达式, 则需要注意以下几点:
   1. 乘法在Ruby中的形式为 1*2
   2. 除法在Ruby中的形式为 32/8
   3. 开平方的形式则为 Math.sqrt(3.5)
   4. 平方的形式则为 3**2 (3的平方)


   如此, 上面的两个表达式在Ruby中会是如下:
#+begin_src ruby
x1 = (-4+Math.sqrt(4**2 - 4*1*1) )/2
x2 = (-4-Math.sqrt(4**2 - 4*1*1) )/2
#+end_src
   如果将这两句话复制, 放入irb中分别执行, 结果会分别是
#+begin_src sh
irb(main):003:0> x1 = (-4+Math.sqrt(4**2 - 4*1*1) )/2
=> -0.2679491924311228
irb(main):004:0> x2 = (-4-Math.sqrt(4**2 - 4*1*1) )/2
=> -3.732050807568877
#+end_src
   你会发现, 每执行一句表达式, 表达式的结果都会在irb的模式中显示出来.

** 可以通用的表达式 - 变量
   利用上面的表达式, 已经可以用于解一元二次方程, 但是不同的方程都需要输入整个表达式, 为了增加灵活性, 我们需要引入一个更加抽象[fn:1]的概念: 变量

*** 变量 vs 常量
    变量是一个可以变化的值, 对应的, 不变化的值会是常数, 在数学中最明显的一个常量就是圆周率: $\pi$ .
*** 变量表达式
    由于变量是一次抽象, 我们需要一个符号系统来表达这样的一次抽象, 形成一个更加通用的表达式. 事实上, 一元二次方程的通用表示就是存在变量的表达式:
    $$ax^2+bx+c=0 $$
    对应的, 其解的通用表达式就是:
    $$ x_{0,1}=\frac{-b \pm \sqrt{b^2 - 4\times a\times c}}{2\times a}$$

*** Ruby中通用解的表达式
    按照上面的通用表达式的表示, 我们就可以写出两个解在Ruby中的通用表示
#+begin_src ruby
x1 = (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
x2 = (-b-Math.sqrt(b**2 - 4*a*c) )/ (2*a)
#+end_src
    
    当然, 如果直接输入这一表达式, 会出现错误:
#+begin_src sh
irb(main):005:0> x1 = (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
NameError: undefined local variable or method `b' for main:Object
	from (irb):5
	from /usr/bin/irb:12:in `<main>'
#+end_src
    
    这一错误的原因在于, 上述表达式的=右侧, 是抽象的, 我们尚未制定 a, b, c三者的值, 而=右侧希望获得的是一个具体的值. 为此, 我们需要指定a, b, c的具体值. 在irb中的过程如下:
#+begin_src sh
irb(main):014:0> a = 1
=> 1
irb(main):015:0> b = 4
=> 4
irb(main):016:0> c = 1
=> 1
irb(main):017:0> x1 = (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
=> -0.2679491924311228
irb(main):018:0> 
#+end_src
    x2的表达式也类似, 但是由于在之前已经有了指定, 就不再需要重新指定 a, b, c三者的值了. 这样, 之后的计算就不再需要根据a, b, c的不同值重新输入整个表达式了, 只需要重新指定a, b, c然后使用相同的通用表达式就可以获得方程的解了.

    我们可以将变量理解为一个桶, 根据需要, 往桶里放东西. 那么上面的通用表达式可以认为是针对名字分别叫做a b c的三个桶中装的东西的生产线. 我们每次将不同的原料往桶里装, 然后送到生产线中, 经过一番加工后就会获得生产线的产品, 这里, 我们叫这条生产线为"获得一元二次方程的解", 生产线的原料则是"组成方程的三个数值", 此时作为工人的我们, 需要知道生产线的使用说明: "按照严格的顺序, 将三个数值放入对应的桶里, 启动生产, 就会获得结果". 考虑到, 这一生产线其实也是我们设计+建造的, 从这个角度来看, 我们又是设计和生成这一生产线的工程师+工人.
    
    其实, 我们连每次重新输入通用表达式都觉得太麻烦. 这其实就是进一步抽象的动机(懒惰). 我们可以将通用表达式也指定到一个变量上, 后续, 比如起个名字叫做 "生产线1", 以后就不用每次都把整个生成线都写出来了. 这一懒惰的行为, 我们暂时不表, 后面会再深入"懒惰"这个主题.

** 更加复杂的表达式 - 程序的流程
   如果我们在irb中输入下面的内容, 就会出现错误:
#+begin_src sh
irb(main):026:0> a = 4
=> 4
irb(main):027:0> b = 1
=> 1
irb(main):028:0> c = 3
=> 3
irb(main):029:0> (-b+Math.sqrt(b**2 - 4*a*c) )/ (2*a)
Math::DomainError: Numerical argument is out of domain - "sqrt"
	from (irb):29:in `sqrt'
	from (irb):29
	from /usr/bin/irb:12:in `<main>'
#+end_src
   因为, 方程存在无解的情况, 我们不能对负数进行开方(起码目前不能). 那么, 问题来了, 我们如何判断方程是否有解和无解呢?
*** 判断语句 - if
    
*** 逻辑系统
*** while
** 处理复杂的表达式 - 模块化 - 函数/子例程/代码快/方法
*** 实数解与复数解
** 解释与可读性 - 注释
** 程序正确的基石 - 类型系统
   就像我们对家人的称呼, 父母[fn:2]可以认为是常量, 因为我们的父母不会有变化, 出生时就决定了.
   与物理单位的类似性
** 常用类型 - string
** 外界的交互 - IO系统
** 常用类型 - 标准库
** 现实世界的投射 - 面向对象
** 与代码质量的长期斗争 - 版本控制/复查/测试
** 乐高积木 - 模块化
** 编写自己的网站 - Rails
*** HTTP协议的过程
** Meta Programming
* Footnotes

[fn:1] 编写程序就是一个抽象与具体互相转化的过程.

[fn:2] 我们只考虑在现有技术条件下, 生物学意义上的父母.



